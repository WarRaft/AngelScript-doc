# Типы данных

## Целые числа

| Тип          | Минимум                    | Максимум                   |
|--------------|----------------------------|----------------------------|
| int8         | -128                       | 127                        |
| int16        | -32,768                    | 32,767                     |
| int32, int   | -2,147,483,648             | 2,147,483,647              |
| int64        | -9,223,372,036,854,775,808 | 9,223,372,036,854,775,807  |
| uint8        | 0                          | 255                        |
| uint16       | 0                          | 65,535                     |
| uint32, uint | 0                          | 4,294,967,295              |
| uint64       | 0                          | 18,446,744,073,709,551,615 |

Язык оптимизирован под 32-битные числа и его создатели строго рекомендуют использовать только **int** и **uint**. К
остальным прибегать только в случае крайней необходимости.

## Перечисления

В первом приближении можно относиться к ним как к именованным **int**. Служат для удобного указания набора значений и
являются константами, то бишь изменить их значение в процессе исполнения кода невозможно.

Если не указано иное, то первая константа принимает значение __0__. Остальные принимают значение равное увеличенному на
единицу значению предыдущей:

```C++
enum MyEnum {
A, // 0
B, // 1
C, // 2
D = (B+C) * 2, // 6
E // 7
}
void main(){
print( MyEnum::D ); // Выведет: 6
print( E ); // Если нет коллизии имён, явное указание перечисления можно опустить
}
```

## Вещественные числа

Тип | Диапазон значений | Минимальное положительное число | Максимальное количество знаков
---
float | +/- 3.402823466e+38 | 1.175494351e-38 | 6
double | +/- 1.79769313486231e+308 | 2.22507385850720e-308 | 15

Вещественные числа в коде определяются точкой и по умолчанию считаются как **double**. Чтоб указать **float** необходимо
явно указать тип:

```C++
float a = 1.f;
double b = .2;
```

## Объекты

Всё, что не является примитивом, то бишь числом, строкой или логическим, является объектом и ведёт себя как примитив,
уничтожаясь после завершения исполнения области видимости.

Все типы, объявленные в [common.j](https://github.com/UnryzeC/UjAPI/blob/main/uJAPIFiles/common.j) внутри языка являются
**uint32** и уничтожается именно это число, а не внутриигровой объект.

## null

Работает **только** с объектами принадлежащими самому языку.

## nil

Специально обученный **null** для примитивов.

## Строки

Строки хранятся в виде массива байтов, то бишь проблема получения длины строки для кириллицы всё ещё актуальна. Для
определения строки в коде используется одна или три двойных кавычки.
Блоки строк идущие подряд будут объединены в одну строку.

```C++
string a = "Это строка!";
string b = """Это "тоже" строка!""";
string c = "Это строка
с переносом!
";
string d =    "Так"
"тоже"
"можно!";
```

Экранирование символов устроено следующим образом:

| Последовательность | Значение     | Описание                                                                                         |
|--------------------|--------------|--------------------------------------------------------------------------------------------------|
| `\0`               | `0`          | null                                                                                             |
| `\\`               | `92`         | обратный слэш                                                                                    |
| `\'`               | `39`         | одинарная кавычка                                                                                |
| `\"`               | `34`         | двойная кавычка                                                                                  |
| `\n`               | `10`         | LF                                                                                               |
| `\r`               | `13`         | CR                                                                                               |
| `\t`               | `9`          | табуляция                                                                                        |
| `\xFFFF`           | `0xFFFF`     | `FFFF` будет заменено на шестнадцатеричное число от 1 до 4 цифр, представляющее искомое значение |
| `\uFFFF`           | `0xFFFF`     | `FFFF` будет заменено на шестнадцатеричное число, представляющее кодовую точку юникода           |
| `\UFFFFFFFF`       | `0xFFFFFFFF` | `FFFFFFFF` будет заменено на шестнадцатеричное число, представляющее кодовую точку юникода       |

Работайте с юникод последовательностями осторожно, ибо в игре всё это склеено через одно место и может отвалиться в
любой момент.

=== Присваивание ===
Строки, как и примитивы, присваиваются по значению с помощью [оператора](https://xgm.guru/p/ij/angelscript-operator)
присваивания.

Приоритет | Ассоциативность | Оператор | Описание | Пример
---
15 | Правая | = | Присваивание | a=b

```C++
string A = "Будет создан массив байт который будет эквивалентен представлению этого текста";
string B = A; //Будет создана копия массива байт переменной A и присвоен переменной B
```

=== Конкатенация ===
В первом приближении [конкатенация](https://w.wiki/9eWw) это просто склеивание нескольких строк в одну с
помощью [операторов](https://xgm.guru/p/ij/angelscript-operator) сложения.

Приоритет | Ассоциативность | Оператор | Описание | Пример
---
6 | Левая | + | Сложение | a+b
15 | Правая | += | Присваивающее сложение | a+=b

```C++
string A = "Эти" "литералы" "будут" "объединены" "в" "одну" "строку" "при" "компиляции";
string B = A + "Конкатенация с помощью оператора сложения"
string C = B + 1 + 2.f + true; // Конкатенация примитивов допустима
void main(){
С += "Конкатенация с помощью присваивающего сложения";
}
```

=== Равенство ===
Применяет [оператор](https://xgm.guru/p/ij/angelscript-operator) равенства к каждому байту строки. //Строки разной длины
не равны, что логично.

Приоритет | Ассоциативность | Оператор | Описание | Пример
---
9 | Левая | == | Равно | a==b
9 | Левая | != | Не равно | a!=b

```C++
bool A = "A" == "B"; // false
bool B = "A" != "B"; // true
```

=== Сравнение ===
Применяет [оператор](https://xgm.guru/p/ij/angelscript-operator) сравнения к каждому байту строки.

Приоритет | Ассоциативность | Оператор | Описание | Пример
---
8 | Левая | < | Меньше | a<b
8 | Левая | > | Больше | a>b
8 | Левая | <= | Меньше или равно | a<=b
8 | Левая | >= | Больше или равно | a>=b

Если байты на одной и той же позиции в обеих строках равны, сравнение продолжается сравнением следующих байт. Если в
какой-то момент байты не равны, строка с большим значением байта считается большей.

Если строки разной длины одинаковы до момента различия длин, то большей считается более длинная строка.

```C++
bool A = "Z" > "A"; // true: байтовое представление Z = 90, A = 65
bool B = "Z" > "AAAAA"; // true: несмотря на большую длину, сравнение будет окончено на первом же байте Z > A
bool C = "Z" > "ZZ"; // false: байты на первой позиции одинаковы, на второй же позиции у первой строки нет байт
bool D = "ZZ" >= "ZZ"; // true: строки побайтово равны
```

//Напоминаю, что строки представляют массив байт и сравнение кирилицы может привести к неожиданным результатам.

=== Доступ по индексу ===
Существует возможность получить значение байта используя оператор доступа по индексу.

Приоритет | Ассоциативность | Оператор | Описание | Пример
---
2 | Левая | [] | Доступ к индексу | a[b]

```C++
void main(){
int8 A = "AZ";
print( A[0] ); // Выведет: 65
int8 B = "Z"[0];
}
```

=== length ===
Возвращает размер массива байт.
```C++
void main(){
uint A = "🍒".length();
print(A); // Выведет: 4
}
```

=== resize ===
Изменяет размер массива содержащего строку.
```C++
void resize(uint)
```

```C++
string A = "0123456789".resize(4); // "0123" - при уменьшении размера лишние байты обрезаются, будте осторожны с
мультибайтными символами
string B = "0123".resize(10); // "0123\0\0\0\0\0\0" - при увеличении размера в массив будут добавлены нулевые байты
```

=== isEmpty ===
Возвращает **true** если строка пуста, //тобишь массив имеет размер ноль.
```C++
// Записи ниже эквивалентны
bool A = "".isEmpty();
bool B = "".length() == 0;
```

=== substr ===
Возвращает новую строку, которая инициализирована значениями исходной строки. //Работает с байтами, поэтому используйте
аккуратно, если не хотите повредить мультибайтные символы.
```C++
string substr(uint start = 0, int count = -1)
```

- **start** - позиция первого байта, который попадёт в новую строку. //Так как строки это массив байт, то отчёт
  начинается с ноля
- **count** - максимальное количество байт которые попадут в новую строку. Если значение меньше ноля, то в новую строку
  попадут все оставшиеся байты
- 
```C++
string A = "0123456789".substr(0,-1); // "0123456789" - значения по умолчанию соответствуют исходной строке
string B = "0123456789".substr(3,4); // "3456" - находим байт на третьей позиции и отсчитываем четыре байта включая
найденный
string C = "0123456789".substr(9,100); // "9" - если count превышает размер строки то будет скопировано столько байт
сколько возможно
```

=== insert ===
Вставляет в строку другую строку. //Работает с байтами, поэтому используйте аккуратно, если не хотите повредить
мультибайтные символы.
```C++
void insert(uint pos, const string &in other)
```

- **pos** - позиция первого байта куда будет произведена вставка
- **other** - строка, которая будет вставлена

```C++
string A = "0123456789".insert(5,"_"); // "01234_56789"
```

Этот метод не изменяет значение текущей строки, а создаёт новую.

=== find* ===
Набор методов, которые возвращают позицию первого или последнего совпадения.
```C++
int findFirst(const string &in str, uint start = 0)
int findLast(const string &in str, int start = -1)
int findFirstOf(const string &in chars, int start = 0)
int findFirstNotOf(const string &in chars, int start = 0)
int findLastOf(const string &in chars, int start = -1)
int findLastNotOf(const string &in chars, int start = -1)
```

- **str** - поиск завершится если будет найдено **полное** совпадение с искомой строкой
- **chars** - поиск завершится если будет найдено совпадение с **любым** из байт переданной строки.
- **strart** - позиция, с которой начнётся поиск

```C++
int A = "01234567890".findFirst("0"); // 0
int B = "01234567890".findLast("0"); // 10
```

=== split ===
Разбивает строку в массив строк используя разделитель. Если разделитель не присутствует в строке, то вся строка будет
помещена в первый элемент массива. //Работает с байтами, поэтому используйте аккуратно, если не хотите повредить
мультибайтные символы.
```C++
array<string>@ split(const string &in delimiter)
```

- **delimiter** - разделитель

```C++
array<string> A@ = "0-1-2-3".split("-"); // ["0","1","2","3"]
array<string> B@ = "0-1-2-3".split("?"); // ["0-1-2-3"]
array<string> A@ = "0-1-2-3".split(""); // ["0","-","1","-","2","-","3"]
```

=== join ===
Объединяет все элементы массива строк в строку используя разделитель.
```C++
string join(const array<string> &in arr, const string &in delimiter)
```

- **arr** - массив строк
- **delimiter** - разделитель

```C++
string A = join(array<int> = {"1","2","3","4"}, "-"); // "1-2-3-4"
string B = join(array<int> = {"1","2","3","4"}, ""); // "1234"
```

=== parse* ===
Набор методов для превращения строкового представления числа в число.
```C++
int64 parseInt(const string &in str, uint base = 10, uint &out byteCount = 0)
uint64 parseUInt(const string &in str, uint base = 10, uint &out byteCount = 0)
double parseFloat(const string &in str, uint &out byteCount = 0)
```
**str** - строка
**base** - основание [целого числа](https://xgm.guru/p/ij/angelscript-data-types#tselye-chisla), принимает два значения:
**10** или **16**
**byteCount** - [выходное значение](https://xgm.guru/p/ij/angelscript-function#out) в которое устанавливается количество
байт, которые были учтены как значение

```C++
int64 A = parseInt("123"); // 123
uint64 B = parseUInt("0xBAD",16); // 2989
double C = parseFloat("-1"); // -1.0d
```

=== format* ===
Набор функций, для превращения числа в строку используя опции форматирования
```C++
string formatInt(int64 val, const string &in options = "", uint width = 0)
string formatUInt(uint64 val, const string &in options = "", uint width = 0)
string formatFloat(double val, const string &in options = "", uint width = 0, uint precision = 0)
```

- **val** - число
- **options** - набор опций форматирования
- **width** - минимальная длинна получившейся строки. Недостающие символы будут заполнены пробелами.
- **precision** - точность для [вещественных чисел](https://xgm.guru/p/ij/angelscript-data-types#veschestvennye-chisla)

```C++
// l - выравнивание по левому краю
string A = formatInt(3, "", 5); // "    3"
string B = formatInt(3, "l", 5); // "3    "

// 0 - вставляет нули перед число до достижения указанной длины
string C = formatInt(13, "0", 5); // "00013"
string D = formatInt(13, "0", 1); // "13"

// + - всегда указывать знак, если возможно
string E = formatInt(3, "+"); // "+3"

// пробел - добавляет перед положительным числом
string E = formatInt(3, " "); // " 3"
string F = formatInt(-3, " "); // "-3"

// h - использует шестнадцатеричную запись в нижнем регистре, не применимо для formatFloat
// H - использует шестнадцатеричную запись в верхнем регистре, не применимо для formatFloat
string G = formatInt(2989, "h"); // "0xbad"
string H = formatInt(2989, "H"); // "0xBAD"

// e - экспоненциальная запись в нижнем регистре, только для formatFloat
// E - экспоненциальная запись в верхнем регистре, только для formatFloat
string I = formatFloat(1.2345 * 10^4, "e"); // "1.2345e+4"
string J = formatFloat(1.2345 * 10^4, "E"); // "1.2345E+4"
```