<show-structure for="chapter,procedure" depth="3"/>

# Аргументы функции

Функции могут иметь [параметры](https://w.wiki/9pwD) - специальные переменные, которые являются частью сигнатуры
функции. Когда у функции есть параметры, вы можете предоставить ей конкретные значения этих параметров.

> Технически конкретные значения называются аргументами, но такое разделение, как ни парадоксально, вносит много
> путаницы.
> Поэтому здесь и далее термины [параметр](https://w.wiki/9vig) и [аргумент](https://w.wiki/8NLF) будут использованы как
> взаимозаменяемые для обозначения либо переменных в определении функции, либо конкретных
> значений, передаваемых при вызове функции.

```C#
void A(string B, string C) { // Объявление функции с именем A, которая принимает две строки B и C
    print(B+" "+C); // Делаем конкатенацию строк и выводим результат в консоль
}
void [[[main|main.md]]](){
    A("Продам", "гараж"); // Вызываем функцию A и передаём ей две строки аргументами
}
```

> Если аргументов больше одного, то они вычисляются в обратном порядке, то бишь последний аргумент будет вычислен
> первым.

## const

Так же как и в [переменных](var.md#const), ключевое слово `const` запрещает
изменение значения аргумента в процессе исполнения функции.

```C#
void A(const int B){
    B++; // Ошибка! Аргумент B объявлен как const
}
void [[[main|main.md]]](){
    A(5);
}
```

## Начальные значения аргументов

Аргументам можно установить начальное значение которое будет подставлено компилятором если аргумент не будет передан.
Если одному из аргументов указано начальное значение, то всем последующим аргументам оно так же должно быть установлено.

```C#
string A = "Москве";

void B(string C, string D="гараж", string E=A){
    print(C+" "+D+" в "+E+"\n");
}

void [[[main|main.md]]](){
    B("Продам"); // Выведет: Продам гараж в Москве
    B("Продам", "квартиру"); // Выведет: Продам квартиру в Москве
    B("Пропью", "деньги", "кабаке"); // Выведет: Пропью деньги в кабаке
}
```

> Начальное значение аргумента может включать переменные или вызов функций только если они доступны из глобальной
> области видимости.

## Аргументы по ссылке

По умолчанию аргументы в функцию передаются по значению, то бишь при входе в функцию значения всех переданных в функцию
аргументов копируются. Для расширения возможностей существует несколько типов передачи аргументов по ссылке.

### in

Входящая ссылка _только_ для чтения. При работе со строками может сэкономить вам памяти, так как не будет происходить
копирование памяти.

```C#
void A(string& in B){
    print(B);
}
string C = "Привет!";
void [[[main|main.md]]] {
    A(C); // В функцию будет передана ссылка на переменную, копирование памяти не произойдёт.
    A("Допустимо передавать значение напрямую без помещения в переменную");
}
```

> Использование с [примитивами](data-types.md#primitive) допустимо, но бесполезно.

#### const {id="in_const"}

При попытке присвоить значение входящей ссылке компилятор сгенерирует ошибку. Посему для пущей оптимизации и явного
указания недопустимости записи рекомендуется явно указывать [const](https://xgm.guru/p/ij/angelscript-function#const):

```C#
void A(string& in B, const string& in C){
    B = "Ошибка! Запрещено присваивать значение входящим ссылкам!";
    C = "Ошибка! Аргумент C объявлен как const"
}
```

### out

Ссылка для записи выходного значения.

```C#
int divide(int a, int b, int& out remainder) {
    remainder = a % b; // записываем остаток от деления в переменную для выхода
    return a / b; // возвращаем результат деления
}

void [[[main|main.md]]]() {
    int remainder;
    int result = divide(10, 3, remainder);
}
```

С помощью ключевого слова `void` можно сделать выходной параметр необязательным.

```C#
int divide(int a, int b, int& out remainder = void) {
    remainder = a % b; // записываем остаток от деления в переменную для выхода
    return a / b; // возвращаем результат деления
}

void [[[main|main.md]]]() {
    int result = divide(10, 3);
}
```

### inout {id="inout"}

Ссылка для входа-выхода. Просто указывает на фактическое значение. Для обеспечения гарантии того, что ссылка будет
существовать всё время существования функции разрешено передавать только ссылочные типы.

> Рекомендуется использовать короткую запись в виде `&`.

```C#
funcdef void A(); // Объявляем сигнатуру функции.
void B(){
    print("Функция вызвана по ссылке");
}
void C(A& D){
    D(); // Вызываем функцию, переданную по ссылке
};
void [[[main|main.md]]](){
    C(@B); // Передаём функцию по ссылке
}
```