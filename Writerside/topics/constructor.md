# Конструктор класса

[](https://www.angelcode.com/angelscript/sdk/docs/manual/doc_script_class_construct.html)

Конструкторы класса — это специальные методы, используемые для создания новых экземпляров класса.

Конструкторы объявляются без возвращаемого типа и должны иметь то же имя, что и сам класс.

## Конструктор по умолчанию {id="default"}

Если не объявлен ни один конструктор, то при компиляции будет создан конструктор по умолчанию.

```C#
class A {
    // Явное объявление конструктора по умолчанию
    A(){
        print("Вызван конструктор по умолчанию");
    }
}

void [[[main|main.md]]](){
    A a;
}
```

## Перегрузка конструкторов {id="overload"}

Как и в случае с [функциями](fun-overload.md), допустима перегрузка конструкторов.

```C#
class A {   
    A(string a){
        print(a);
    }
}

void [[[main|main.md]]](){
    A a("Создаём экземпляр с помощью перегруженного конструктора");
}
```

Один конструктор не может вызывать другой конструктор. Если вы хотите обмениваться реализациями в конструкторах, вам
следует использовать для этого специальный [метод](class-method.md).

## Копирующий конструктор {id="copy"}

Копирующий конструктор — это специальный конструктор, который может быть использован для создания более
производительного кода.

Без копирующего конструктора компилятор будет вынужден сначала создать копию с помощью конструктора по умолчанию, а
затем скопировать атрибуты с помощью метода `opAssign`.

```C#
class A {
    string s;
    
    A(string s){
        [[[this|this.md]]].s = s;
    }
    
    A([[[const|variable.md#const]]] A [[[&inout|fun-arg.md#inout]]] a) {
        s = a.s + "1"; // Добавим единичку, чтоб убедиться в вызове конструктора
    } 
}

void [[[main|main.md]]](){
     A a("a");
     A b = a; // Создаём копию класса
     print(a.s + b.s); // aa1
     
     // Проверям то, что классы разные
     a.s = "b";
     b.s = "c";
     print(a.s + b.s); // bc
}
```

> В
> [документации](https://www.angelcode.com/angelscript/sdk/docs/manual/doc_script_class_construct.html#doc_script_class_construct_auto)
> написано, что в некоторых случаях копирующий конструктор будет сгенерирован автоматически. Написать пример это
> подтверждающий у меня не вышло.
> Если из примера выше убрать копирующий конструктор, то компилятор выдаст ошибку.

## Приведение типов {id="cast"}

Конструкторы, принимающие один [аргумент](fun-arg.md) могут быть использованы в качестве конструктора при приведении
типов.

```C#
class A {
    string s;
    
    A(){
        s = "a";
    }
    
    A([[[const|variable.md#const]]] string s){
        [[[this|this.md]]].s = s;
    } 
}

void [[[main|main.md]]](){
     A a;
     print(a.s); // a
     a = "b"; // Неявно создаём новый экземпляр класса 
     print(a.s); // b     
}
```

### explicit {id="explicit"}

Для того чтобы разрешить только явное использование конструктора, необходимо использовать ключевое слово `explicit`.

```C#
class A {
    string s;
    
    A(){
        s = "a";
    }
    
    A([[[const|variable.md#const]]] string s) explicit {
        [[[this|this.md]]].s = s;
    } 
}

void [[[main|main.md]]](){
    A a;
    print(a.s); // a
    a = A("b"); // Явно создаём новый экземпляр класса
    // a = "b"; // Ошибка! Неявное создание запрещено 
    print(a.s); // b     
}
```

