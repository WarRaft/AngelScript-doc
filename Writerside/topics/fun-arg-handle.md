# Аргументы по ссылке

По умолчанию аргументы в функцию передаются по значению, то бишь при входе в функцию значения всех переданных в функцию
аргументов копируются. Для расширения возможностей существует несколько типов передачи аргументов по ссылке.

## in {id="in"}

Входящая ссылка только для чтения. При работе со строками может сэкономить вам памяти, так как не будет происходить
копирование памяти.

```C#
void A(string& in B){
    print(B);
}
string C = "Привет!";
void [[[main|main.md]]] {
    A(C); // В функцию будет передана ссылка на переменную, копирование памяти не произойдёт.
    A("Допустимо передавать значение напрямую без помещения в переменную");
}
```

> Использование с [примитивами](data-types.md#primitive) допустимо, но бесполезно.

### const {id="in-const"}

При попытке присвоить значение входящей ссылке компилятор сгенерирует ошибку. Посему для пущей оптимизации и явного
указания недопустимости записи рекомендуется явно указывать [const](https://xgm.guru/p/ij/angelscript-function#const):

```C#
void A(string& in B, const string& in C){
    B = "Ошибка! Запрещено присваивать значение входящим ссылкам!";
    C = "Ошибка! Аргумент C объявлен как const"
}
```

### out {id="out"}

Ссылка для записи выходного значения.

```C#
int divide(int a, int b, int& out remainder) {
    remainder = a % b; // записываем остаток от деления в переменную для выхода
    return a / b; // возвращаем результат деления
}

void [[[main|main.md]]]() {
    int remainder;
    int result = divide(10, 3, remainder);
}
```

С помощью ключевого слова `void` можно сделать выходной параметр необязательным.

```C#
int divide(int a, int b, int& out remainder = void) {
    remainder = a % b; // записываем остаток от деления в переменную для выхода
    return a / b; // возвращаем результат деления
}

void [[[main|main.md]]]() {
    int result = divide(10, 3);
}
```

## inout {id="inout"}

Ссылка для входа-выхода. Просто указывает на фактическое значение. Для обеспечения гарантии того, что ссылка будет
существовать всё время существования функции разрешено передавать только ссылочные типы.

> Рекомендуется использовать короткую запись в виде `&`.

```C#
funcdef void A(); // Объявляем сигнатуру функции.
void B(){
    print("Функция вызвана по ссылке");
}
void C(A& D){
    D(); // Вызываем функцию, переданную по ссылке
};
void [[[main|main.md]]](){
    C(@B); // Передаём функцию по ссылке
}
```