<show-structure for="chapter,procedure" depth="2"/>

# Выражения

<a href="https://www.angelcode.com/angelscript/sdk/docs/manual/doc_expressions.html"/>

[Выражение](https://w.wiki/9kCz) это комбинация из одной или
нескольких [переменных](variable.md), [функций](function.md) и [операторов](operator.md), результатом интерпретации
которого становится некоторое значение.

## Интерпретация

С точки зрения интерпретатора любое выражение представляется как функция. Возьмём
простейшее [объявление](variable.md#declaration) и переменной с [начальным значением](variable.md#init):

```C++
int A = 1;
```

Опустив тип, для краткости повествования, интерпретатор выполнит две операции:

```C++
DECLARE(A); // Объявление переменной
ASSIGN(A, 1); // Установка значения
```

> На самом деле всё немного сложнее, но в первом приближении прекрасно даёт понять суть происходящего.

Немного усложним пример:

```C++
int A = 1 + 3;
```

Операции будут выглядеть таким образом:

```C++
DECLARE(A); // Объявление переменной
ASSIGN(A, ADD(1, 3)); // Установка значения
```

Как видите, набор операторов превращается в функции, аргументы которых зовутся операндами.

## Приоритет

Возьмём предыдущий пример и уберём [объявление](variable.md#declaration):

```C++
A = 1 + 3;
```

Как видите, есть две операции:
- `A = 1`
- `1 + 3`

Чтоб интерпретатору понять, как правильно подобрать функции существует приоритет, узнать который можно в
соответствующей [таблице](operator.md). Оператор `+` имеет более высокий приоритет, посему он первым и превратится в
функцию:

```C++
A = ADD(1, 3);
```

Вторым и заключительным действием для этого выражения будет обработка оператора `=`:

```C++
ASSIGN(A, ADD(1, 3));
```

### Оператор скобки

Скобки просто возвращают содержащееся в них выражение:

```C++
A = (1); // 1
```
> Литералы тоже считаются выражением, результатом выполнения которого является его значение.

```C++
ASSIGN(A, PAREN(1)); // Parenthesis - круглые скобки
```

Это свойство скобок зачастую используется для смены порядка операторов:

```C++
A = 1 + 2 * 3; // 7
B = (1 + 2) * 3; // 9
```

```C++
ASSIGN(A, ADD(1, MUL(2, 3))); // Addition - сложение
ASSIGN(B, MUL(ADD(1, 2), 3)); // Multiplication - умножение
```

## Ассоциативность

Возьмём простой пример:

```C++
1 - 3 + 5;
```

> Хоть результат вычисления такого выражения нигде не использован, такое выражение вполне легально.

У нас снова есть две операции:

- `1 - 3`
- `3 + 5`

Руководствоваться приоритетом в данном случае не получится, у операторов `-` и `+` он одинаков. В таком случае на помощь
приходит ассоциативность, которая указана в соответствующей [таблице](operator.md). Для операторов в нашем примере она
левая, то бишь они будут разобраны слева на право. Сначала вычитание:

```C++
DIV(1, 3) + 5; // Division - вычитание
```

Затем сложение:

```C++
ADD(DIV(1, 3), 5);
```

Рассмотрим так же правую ассоциативность на примере оператора `=`:

```C++
A = B = 5;
```

По традиции у нас есть две операции:

- `A = B`
- `B = 5`

Так как присваивание `B` правее, оно и будет первым:

```C++
ASSIGN(B, 5);
ASSIGN(A, B);
```